
* tiny-lsp-client

* todos:

dir with test projects/repos

for tests, have one .el file per test case. It loads the rust module, runs initialize, starts some LSP server, sends some requests and asserts responses. If fail, either due to crash or enexpected value, maybe then and only then error code is non-0? Can check error code in .sh script. Can have as arg to sh both .el file to run and whether to have gui. gui useful to manually debug, non-gui good for regression testing.

- +phase 1: basics + find definition+
- +phase 2: erlang+
- phase 3: completions
- phase 4: make public
  - architecture
  - error strategy
  - logging
  - test strategy
  - licenses and attribution
- Bugs
  - Higher priority
    - unicode support in URIs, need percentage encoding
    - unicode/utf8/utf16 position offset not working. Be non-compliant and onyl support the convenient one
  - Lower priority
    - Sometimes duplicate didOpen/didClose
    - At stop, sometimes get duplicate didOpen due to mode and server out of sync
- Improvements
  - Higher priority
    - make erlang_ls etc test dependencies
    - use full sync on didChange as fallback
  - Lower priority
    - in general, ensure no bad args sent to rust. e.g. stop-server with "path" because doesn't start with /
    - make (root, lang) key, so that one project with multiple languages can be supported.
    - consider caching didChange like eglot
    - Clean up server.rs by having smaller functions (like read_header) and having a flatter sructure since break can return early.
    - tests
      - Use clangd instead of rust-analyzer for rust tests
      - Separate lisp level rust-analyzer tests
      - More unit tests
