
* tiny-lsp-client

* todos:

dir with test projects/repos

for tests, have one .el file per test case. It loads the rust module, runs initialize, starts some LSP server, sends some requests and asserts responses. If fail, either due to crash or enexpected value, maybe then and only then error code is non-0? Can check error code in .sh script. Can have as arg to sh both .el file to run and whether to have gui. gui useful to manually debug, non-gui good for regression testing.

- +phase 1: basics + find definition+
- +phase 2: erlang+
- phase 3: completions
- phase 4: make public
  - architecture
  - error strategy
  - logging
  - test strategy
  - licenses and attribution
- Bugs
  - Higher priority
    - clangd: jump to thing in lib file
  - Lower priority
    - Sometimes duplicate didOpen/didClose
    - At stop, sometimes get duplicate didOpen due to mode and server out of sync
- Improvements
  - Higher priority
    - split lisp tests into smaller files. e.g. one for edit. one for revert. etc
    - test unicode in content
    - test unicode in URIs
    - make erlang_ls etc test dependencies
    - use full sync on didChange as fallback
  - Lower priority
    - in general, ensure no bad args sent to rust. e.g. stop-server with "path" because doesn't start with /
    - make (root, lang) key, so that one project with multiple languages can be supported.
    - consider caching didChange like eglot
    - Clean up server.rs by having smaller functions (like read_header) and having a flatter sructure since break can return early.
