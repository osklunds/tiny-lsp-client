
* tiny-lsp-client

* todos:

dir with test projects/repos

for tests, have one .el file per test case. It loads the rust module, runs initialize, starts some LSP server, sends some requests and asserts responses. If fail, either due to crash or enexpected value, maybe then and only then error code is non-0? Can check error code in .sh script. Can have as arg to sh both .el file to run and whether to have gui. gui useful to manually debug, non-gui good for regression testing.

- +phase 1: basics + find definition+
- +phase 2: erlang+
- phase 3: completions
  - bug: rust-analyzer sometimes returns null as result
  - async
  - fast filter ala lsp-bridge
- phase 4: make public
  - architecture
  - error strategy
  - logging
  - test strategy
  - licenses and attribution
- Bugs
  - Higher priority
    - unicode support in URIs, need percentage encoding
    - unicode/utf8/utf16 position offset not working. Be non-compliant and onyl support the convenient one
  - Lower priority
    - Sometimes duplicate didOpen/didClose
    - At stop, sometimes get duplicate didOpen due to mode and server out of sync
    - If no server in current root, stop should set it as default
- Improvements
  - Higher priority
    - make erlang_ls etc test dependencies
    - use full sync on didChange as fallback
    - use try_recv_timeout wht 0.1s in rust, so that no busy wait in lisp, but still frequent possibilities to C-g. Can also fix exceed lisp nesting
    - if user answers no to restart server, disable mode
  - Lower priority
    - in general, ensure no bad args sent to rust. e.g. stop-server with "path" because doesn't start with /
    - make (root, lang) key, so that one project with multiple languages can be supported.
    - consider caching didChange like eglot
    - Clean up server.rs by having smaller functions (like read_header) and having a flatter sructure since break can return early.
    - tests
      - Use clangd instead of rust-analyzer for rust tests
      - Separate lisp level rust-analyzer tests
      - More unit tests

* notes

rust-analzyer completion:
{
  "additionalTextEdits": [],
  "deprecated": false,
  "filterText": "S",
  "kind": 25,
  "label": "S",
  "sortText": "7fffffff",
  "textEdit": {
    "newText": "S",
    "range": {
      "end": {
        "character": 6,
        "line": 493
      },
      "start": {
        "character": 4,
        "line": 493
      }
    }
  }
}
clangd completion:
{
  "detail": "long",
  "filterText": "my_function4",
  "insertText": "my_function4",
  "insertTextFormat": 1,
  "kind": 3,
  "label": " my_function4()",
  "score": 1.0087924003601074,
  "sortText": "407edfe4my_function4",
  "textEdit": {
    "newText": "my_function4",
    "range": {
      "end": {
        "character": 6,
        "line": 25
      },
      "start": {
        "character": 4,
        "line": 25
      }
    }
  }
}
erlang_ls completion:
{
  "kind": 14,
  "label": "when"
},
{
  "kind": 14,
  "label": "xor"
},
{
  "data": {},
  "insertText": "binary_to_atom",
  "insertTextFormat": 1,
  "kind": 3,
  "label": "binary_to_atom/1"
},
{
  "data": {},
  "insertText": "binary_to_existing_atom",
  "insertTextFormat": 1,
  "kind": 3,
  "label": "binary_to_existing_atom/1"
},
